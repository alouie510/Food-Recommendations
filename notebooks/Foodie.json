{"paragraphs":[{"text":"%pyspark\n\n##########################\n#\n# FULL ANALYSIS\n#\n##########################\n\nimport torch\nimport torch.nn as nn\nfrom torch.autograd import Variable\nimport torchvision.transforms as transforms\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport os\nimport sys\nimport matplotlib.pyplot as plt\nfrom matplotlib import mlab\nimport numpy as np\nimport pandas as pd\n\n\n# LOGISTIC REGRESSION CLASSIFICATION VARIABLES\ntestDataSize = 30 # DO NOT TOUCH: amount of recommended food items outputted (keep under 10% of total)\ninputSize = 4 # DO NOT TOUCH: num of food item categories for classification\nnumClasses = 2 # DO NOT TOUCH: num of food classification classes (like/dislike)\nnumEpochs = 30 \ntrainBatchSize = 20\ntestBatchSize = 15\nlearningRate = 0.0001\nlikeWeight = 1.05  # added weight to mean rating value for cutoff point\n\n# LINEAR REGRESSION VARIABLES\nlinDataSize = 3000 # DO NOT TOUCH: amount of data used for lin reg training (prevents overfitting)\nlinNumEpochs = 250\nlinLearningRate = 0.01\n\n\n# LAMBDA FUNCTIONS\n# Function Description: reduces data from raw data to data amount per calories ratio (protein, fat, sodium)\ndef quantityToRatio(row, option):\n    calories = row['calories']\n    if calories > 0:\n        return row[option] / calories\n    else:\n        return row[option]\n\n# Function Description: turn food ratings into percentages (better interpretation)        \ndef normalizeRatings(row, maxi):\n    if maxi < 5:\n        maxi = (maxi + 10) / 3\n    if maxi > 0:\n        if row['rating'] == maxi:\n            return 99\n        else:\n            return (row['rating'] / maxi) * 100\n    else:\n        return row['rating']\n\n# Function Description: deciphers between 'liked' and 'disliked' classes\ndef labelLike(row, mean, likeWeight):\n    if row['rating'] > likeWeight*mean:\n        return 1 # GOOD\n    else:\n        return 0 # BAD\n\n# Function Description: provides much needed variety within rating category - preprocessing\ndef adjustRating(row, calories, overUnder, allergies):\n    rating = row['rating']\n    if overUnder == \"Gain\":\n        if row['calories'] >= calories:\n            rating = rating * 1.05\n        else:\n            rating = rating * .95\n    else:\n        if row['calories'] <= calories:\n            rating = rating * 1.05\n        else:\n            rating = rating * .95\n    \n    if (\"dairy\" in allergies) and (row['dairy free'] == 1):\n        rating = rating * 1.1\n    if (\"egg\" in allergies) and (row['egg'] == 0):\n        rating = rating * 1.1\n    if (\"tree\" in allergies) and (row['tree nut free'] == 1):\n        rating = rating * 1.1\n    if (\"peanuts\" in allergies) and (row['peanut free'] == 0):\n        rating = rating * 1.1\n    if (\"shell\" in allergies) and (row['shellfish'] == 0):\n        rating = rating * 1.1\n    if (\"soy\" in allergies) and (row['soy free'] == 1):\n        rating = rating * 1.1\n    if (\"fish\" in allergies) and (row['fish'] == 0):\n        rating = rating * 1.1\n    if (\"gluten\" in allergies) and (row['wheat/gluten-free'] == 1):\n        rating = rating * 1.1\n    \n    return rating\n\n\n# LINEAR REGRESSION CLASS\nclass LinearRegressionModel(nn.Module):\n    def __init__(self):\n        super(LinearRegressionModel, self).__init__() \n        self.linear = nn.Linear(4, 1)\n    def forward(self, point):\n        output = self.linear(point)\n        return output\n\n# LOGISTIC REGRESSION CLASSIFICATION CLASS\nclass LogisticRegression(nn.Module):\n    def __init__(self, inputSize, numClasses):\n        super(LogisticRegression, self).__init__()\n        self.linear = nn.Linear(inputSize, numClasses)\n    def forward(self, point):\n        output = self.linear(point)\n        return output\n\n\n# READ DATA + PREPROCESS\ndata = pd.read_csv(\"epi_r.csv\", encoding = 'utf8')\ndf = data[['title','rating','calories','protein','fat','sodium','kosher','pescatarian','vegan','vegetarian', 'dairy free','egg','tree nut free','peanut free','shellfish', 'soy free','fish','wheat/gluten-free','sugar conscious']]\ndf.replace(r'\\s+', np.nan, regex=True)\ndf.replace('', np.nan, regex=True)\ndf.reset_index(level=0, inplace=True)\ndf = df.dropna() # rids of all NAN rows - unable to be used\n\ndf['protein'] = df.apply(lambda row: quantityToRatio (row, \"protein\"),axis=1)\ndf['fat'] = df.apply(lambda row: quantityToRatio (row, \"fat\"),axis=1)\ndf['sodium'] = df.apply(lambda row: quantityToRatio (row, \"sodium\"),axis=1)\n\n\n# USER INPUT (Calories, Preferences, Restrictions, Allergies)\ncalories = int(z.input(\"I want these amount of calories:\", 0))\n\noverUnder = z.select(\"Would you prefer to consume slightly more/less calories?: [Default: Less]\", [(\"Lose\",\"I am trying to lose weight\"), (\"Gain\",\"I am trying to gain weight\")])\n\nrestriction = z.select(\"Do you have any dietary restrictions?:\", [(False,\"No, I do not have any restrictions\"),(True,\"Yes, I do have restrictions\")])\nrestrictions = \"\"\nif restriction == True:\n    restrictions = z.select(\"Restrictions:\", [(\"vegetarian\",\"I am vegetarian\"), (\"vegan\",\"I am vegan\"), (\"pescatarian\",\"I am pescatarian\"), (\"kosher\",\"I am eating kosher\"), (\"diabetic\", \"I am diabetic (low sugar)\")])\n\nallergy = z.select(\"Do you have any food allergies?:\", [(False,\"No, I do not have any allergies\"),(True,\"Yes, I do have allergies\")])\nallergies = []\nif allergy == True:\n    allergens = [(\"dairy\",\"Dairy/Milk\"), (\"eggs\",\"Eggs\"), (\"tree\",\"Tree Nuts\"),  (\"peanuts\",\"Peanuts\"), (\"shell\",\"Shellfish\"), (\"gluten\",\"Wheat/Gluten\"),  (\"fish\",\"Fish\"),  (\"soy\",\"Soy\")]\n    allergies = z.checkbox(\"Allergies:\", allergens)\n\n\n# FIND MATCHING FOOD ITEMS IN DATASET\nfilterDF = df\ntrainDF = df\n# calories\nif overUnder == \"Gain\": # gain weight\n    filterDF = df[df['calories'] >= calories].sort_values(by=['calories', 'rating'], ascending=True, na_position='last').drop_duplicates(subset=['title'])\nelse: # lose weight - default\n    filterDF = df[df['calories'] <= calories].sort_values(by=['calories', 'rating'], ascending=False, na_position='last').drop_duplicates(subset=['title'])\n# restrictions\nif restrictions == \"vegetarian\":\n    filterDF = filterDF[filterDF['vegetarian'] == 1]\nelif restrictions == \"vegan\":\n    filterDF = filterDF[filterDF['vegan'] == 1]\nelif restrictions == \"pescatarian\":\n    veg = filterDF[filterDF['vegan'] == 1]\n    pesc = filterDF[filterDF['pescatarian'] == 1]\n    filterDF = pd.concat([veg,pesc]).drop_duplicates().reset_index(drop=True)\nelif restrictions == \"kosher\":\n    filterDF = filterDF[filterDF['kosher'] == 1]\nelif restrictions == \"diabetic\":\n    filterDF = filterDF[filterDF['sugar conscious'] == 1]\n# allergies\nif \"dairy\" in allergies:\n    filterDF = filterDF[filterDF['dairy free'] == 1]\nif \"egg\" in allergies:\n    filterDF = filterDF[filterDF['egg'] == 0]\nif \"tree\" in allergies:\n    filterDF = filterDF[filterDF['tree nut free'] == 1]\nif \"peanuts\" in allergies:\n    filterDF = filterDF[filterDF['peanut free'] == 0]\nif \"shell\" in allergies:\n    filterDF = filterDF[filterDF['shellfish'] == 0]\nif \"soy\" in allergies:\n    filterDF = filterDF[filterDF['soy free'] == 1]\nif \"fish\" in allergies:\n    filterDF = filterDF[filterDF['fish'] == 0]\nif \"gluten\" in allergies:\n    filterDF = filterDF[filterDF['wheat/gluten-free'] == 1]\n\nfilterDF = filterDF[:testDataSize]\ntrainDF = df.drop(filterDF['index']).drop_duplicates(subset=['title'])\ntrainDF['rating'] = trainDF.apply(lambda row: adjustRating(row, calories, overUnder, allergies),axis=1)\ntrainDF['like'] = trainDF.apply(lambda row: labelLike (row, trainDF['rating'].mean(), likeWeight),axis=1)\ntrainDF = trainDF[['like','rating','calories','protein','fat','sodium','sugar conscious','title']].sort_values(by=['calories'], ascending=False, na_position='last').drop_duplicates(subset=['title'])\n\n\n# LINEAR REGRESSION TRAINING + RESULTS\nlinTrainDF = trainDF.sample(frac=1).reset_index(drop=True).sort_values(by=['calories'], ascending=False, na_position='last')\n\nlinTrainLabelDF = linTrainDF['rating']\nlinTrainLabelDF = linTrainLabelDF[:linDataSize]\n\nlinTrainDataDF = linTrainDF[['protein', 'fat','sodium','sugar conscious']]\nlinTrainDataDF = linTrainDataDF[:linDataSize]\n\nlinTrainLabelTorch = torch.Tensor(np.asarray(linTrainLabelDF).reshape(-1,1))\nlinTrainDataTorch = torch.Tensor(np.asarray(linTrainDataDF).reshape(-1,4))\n\nfilterDFLin = filterDF[['protein','fat','sodium','sugar conscious']].dropna()\nfilterLinTorch = torch.from_numpy(np.array(filterDFLin)).float()\n\nlinModel = LinearRegressionModel()\n\nlinCriterion = nn.MSELoss()\nlinOptimiser = torch.optim.SGD(linModel.parameters(), lr = linLearningRate)\n\nfor epoch in range(linNumEpochs):\n    prediction = linModel(linTrainDataTorch)\n    \n    loss = linCriterion(prediction, linTrainLabelTorch) \n    linOptimiser.zero_grad() \n    loss.backward() \n    linOptimiser.step() \n    \nprediction = linModel(filterLinTorch).data.numpy()\nprediction = pd.DataFrame.from_records(prediction)\nprediction.columns = ['rating']\nprediction = prediction.reset_index(drop=True)\nprediction = prediction.apply(lambda row: normalizeRatings (row, prediction['rating'].max()),axis=1)\n\n\n# LOGISTIC REGRESSION TRAINING + RESULTS\nfilterTitles = filterDF['title']\nfilterDF = filterDF[['protein','fat','sodium','sugar conscious']].dropna()\ntrainDF = trainDF[['like','protein','fat','sodium','sugar conscious']].dropna()\ntrainDF = trainDF[:2250]\n\nfilterTorch = torch.from_numpy(np.array(filterDF))\ntrainTorch = torch.from_numpy(np.array(trainDF))\n\ntestLoader = torch.utils.data.DataLoader(dataset = filterTorch, batch_size = testBatchSize, shuffle = False)\ntrainLoader = torch.utils.data.DataLoader(dataset = trainTorch, batch_size = trainBatchSize, shuffle = True)\n\nmodel = LogisticRegression(inputSize, numClasses)\ncriterion = nn.CrossEntropyLoss() \noptimizer = torch.optim.SGD(model.parameters(), lr = learningRate)\n\nfor epoch in range(numEpochs):\n    for i, block in enumerate(trainLoader):\n        label = Variable(block[:,0].long())\n        features = Variable(block[:,range(1,5)].float())\n\n        optimizer.zero_grad()\n        outputs = model(features)\n        loss = criterion(outputs, label)\n        loss.backward()\n        optimizer.step()\n        \n\n# APPEND CLASSIFICATION TO DATAFRAME\nlabels = np.empty([testDataSize, 1], dtype=int)\nli = 0\n\nfor block in testLoader:\n    features = block.float()\n    output = model.forward(features)\n    addOutput = output.data.numpy()\n\n    for rowI in range(len(addOutput)):\n        row = addOutput[rowI]\n        if row[0] > row[1]:\n            labels[li] = 0\n        else:\n            labels[li] = 1\n\n        li = li + 1\n\nlabelsFrame = pd.DataFrame.from_records(labels)\nlabelsFrame = labelsFrame.reset_index(drop=True)\nfilterDF = filterDF.reset_index(drop=True)\nfilterTitles = filterTitles.reset_index(drop=True)\n\nfilterDF = pd.concat([labelsFrame,filterDF],axis=1)\nfilterDF = pd.concat([filterTitles, filterDF],axis=1)\nfilterDF.columns = ['title', 'score', 'protein', 'fat', 'sodium', 'sugar conscious']\n\nfilterDF = filterDF[filterDF['score'] != 0]\nfilterDF = filterDF['title']\nfilterDF = pd.concat([filterDF, prediction],axis=1).dropna()\nfilterDF.columns = ['title', 'rating']\nfilterDF = filterDF.sort_values(by=['rating'], ascending=False, na_position='last')\n\nif filterDF['title'].empty or filterDF['rating'].empty:\n    print(\"empty\")\nelse:\n    print(filterDF)","user":"anonymous","dateUpdated":"2018-12-17T15:29:38-0500","config":{"colWidth":12,"fontSize":9,"enabled":true,"results":{},"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"editorMode":"ace/mode/python","runOnSelectionChange":true},"settings":{"params":{"I want these amount of calories:":"250","Would you prefer to consume slightly more/less calories?: [Default: Less]":"Lose","Do you have any dietary restrictions?:":"","Do you have any food allergies?:":""},"forms":{"I want these amount of calories:":{"type":"TextBox","name":"I want these amount of calories:","displayName":"I want these amount of calories:","defaultValue":"0","hidden":false,"$$hashKey":"object:1497"},"Would you prefer to consume slightly more/less calories?: [Default: Less]":{"type":"Select","options":[{"value":"Lose","displayName":"I am trying to lose weight","$$hashKey":"object:1521"},{"value":"Gain","displayName":"I am trying to gain weight","$$hashKey":"object:1522"}],"name":"Would you prefer to consume slightly more/less calories?: [Default: Less]","displayName":"Would you prefer to consume slightly more/less calories?: [Default: Less]","defaultValue":"","hidden":false,"$$hashKey":"object:1498"},"Do you have any dietary restrictions?:":{"type":"Select","options":[{"value":false,"displayName":"No, I do not have any restrictions","$$hashKey":"object:1529"},{"value":true,"displayName":"Yes, I do have restrictions","$$hashKey":"object:1530"}],"name":"Do you have any dietary restrictions?:","displayName":"Do you have any dietary restrictions?:","defaultValue":"","hidden":false,"$$hashKey":"object:1499"},"Do you have any food allergies?:":{"type":"Select","options":[{"value":false,"displayName":"No, I do not have any allergies","$$hashKey":"object:1537"},{"value":true,"displayName":"Yes, I do have allergies","$$hashKey":"object:1538"}],"name":"Do you have any food allergies?:","displayName":"Do you have any food allergies?:","defaultValue":"","hidden":false,"$$hashKey":"object:1500"}}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"                                                title     rating\n17                   Indian-Spiced Rice with Lentils   88.064536\n3            Cauliflower, White Bean, and Feta Salad   87.908087\n13          Potato, Artichoke and Feta Cheese Latkes   87.625739\n23      Salmon and Scallop Terrine with Frisée Salad   87.619958\n19                                   Basil Tabbouleh   87.589105\n6                                      Sage Stuffing   87.459972\n4                                   Gratin of Greens   79.592860\n10           Pan-Seared Fish Fillets in Ginger Broth   79.479417\n22   Chilled Crab Cakes with a Tropical Fruit Coulis   79.353028\n2   Radicchio Salad with Pickled Grapes and Goat C...  78.980227\n0                                 Pizza Dough Rounds   78.903524\n25                            Corn-Jalapeño Fritters   78.878188\n16                              Spinach Jewish Style   78.856582\n5   Cauliflower Cheddar Gratin with Horseradish Cr...  78.744028\n"}]},"apps":[],"jobName":"paragraph_1544756247709_726458597","id":"20181213-215727_1109767184","dateCreated":"2018-12-13T21:57:27-0500","dateStarted":"2018-12-17T15:29:38-0500","dateFinished":"2018-12-17T15:29:46-0500","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:169"}],"name":"Foodie","id":"2DYV6XXHE","noteParams":{},"noteForms":{},"angularObjects":{"spark:shared_process":[]},"config":{"isZeppelinNotebookCronEnable":false,"looknfeel":"default","personalizedMode":"false"},"info":{}}